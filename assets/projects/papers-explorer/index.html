<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Papers Explorer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b0d10;
      --panel:#12141a;
      --muted:#9aa3af;
      --ink:#e5e7eb;
      --accent:#60a5fa;   /* buttons/links */
      --title:#a5b4fc;    /* title color */
      --authors:#22d3ee;  /* authors color */
      --hl-bg:#f59e0b;    /* highlight background */
      --hl-fg:#111827;    /* highlight text */
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}
    .wrap{max-width:1100px;margin:0 auto;padding:24px}
    h1{font-size:24px;margin:0 0 12px}
    /* Top row */
    .toolbar{display:grid;grid-template-columns:1fr 140px 220px 160px auto;gap:8px;align-items:center}
    /* Advanced row */
    .advanced{display:grid;grid-template-columns:1fr 120px 1fr 120px;gap:8px;align-items:center;margin-top:8px}
    .toolbar input,.toolbar select,.toolbar button,
    .advanced input,.advanced select,.advanced button{
      background:#1a1e26;color:var(--ink);border:1px solid #2a2f3a;border-radius:10px;padding:10px 12px
    }
    .toolbar button{cursor:pointer;background:#2563eb;border-color:#2563eb}
    .toolbar button.secondary{background:#1a1e26;border-color:#2a2f3a}
    .toolbar .full{grid-column:1 / -1}
    .bar{display:flex;gap:10px;align-items:center;margin-top:10px;color:var(--muted);flex-wrap:wrap}
    .count{font-weight:600;color:#cbd5e1}
    .warning{display:none;margin-top:12px;padding:10px 12px;border:1px solid #ef4444;background:#2a1212;color:#fecaca;border-radius:10px;white-space:pre-wrap}
    .list{margin-top:16px;display:grid;grid-template-columns:1fr;gap:10px}
    .card{background:var(--panel);border:1px solid #2a2f3a;border-radius:14px;padding:14px}
    .title{font-size:16px;font-weight:800;margin:0 0 6px;color:var(--title)}
    .meta{font-size:12px;color:var(--muted);display:flex;gap:8px;flex-wrap:wrap}
    .authors{margin-top:6px;color:var(--authors);font-weight:600}
    .abs{margin-top:8px;color:#d1d5db}
    .links{margin-top:8px;display:flex;gap:12px;flex-wrap:wrap}
    .pill{display:inline-flex;gap:8px;align-items:center}
    .spinner{display:none;margin-left:8px;border:2px solid #2a2f3a;border-top:2px solid var(--accent);border-radius:50%;width:16px;height:16px;animation:spin 0.9s linear infinite}
    mark{background:var(--hl-bg);color:var(--hl-fg);padding:0 .12em;border-radius:.2em}
    @keyframes spin{to{transform:rotate(360deg)}}
    @media (max-width:980px){
      .toolbar{grid-template-columns:1fr 1fr}
      .toolbar .full{grid-column:1 / -1}
      .advanced{grid-template-columns:1fr 100px 1fr 100px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Papers Explorer</h1>

    <!-- Top row -->
    <div class="toolbar">
      <select id="dataset">
        <option value="">Select dataset…</option>
      </select>

      <select id="year"><option value="">Year (all)</option></select>
      <input id="venue" type="search" placeholder="Venue contains… e.g. NeurIPS, CVPR"/>
      <select id="sort">
        <option value="relevance">Sort: Relevance</option>
        <option value="year_desc">Sort: Year ↓</option>
        <option value="year_asc">Sort: Year ↑</option>
        <option value="title_asc">Sort: Title A→Z</option>
      </select>
      <button id="btnClear" class="secondary">Clear</button>

      <div class="full bar">
        <input id="q" class="full" type="search" placeholder="Search title / author / abstract…" style="flex:1 1 420px; min-width:280px" />
        <span id="count" class="count">0 results</span>
        <span id="sources"></span>
        <span id="loading" class="pill">Loading<span class="spinner" id="spin"></span></span>
        <span style="flex:1 1 auto"></span>
        <button id="btnCSV" class="secondary">Download CSV</button>
      </div>
    </div>

    <!-- Advanced exact filters -->
    <div class="advanced">
      <input id="titleFilter" type="search" placeholder="Title filter…">
      <label style="display:flex;gap:6px;align-items:center"><input type="checkbox" id="titleExact"> Exact</label>
      <input id="authorFilter" type="search" placeholder="Author filter…">
      <label style="display:flex;gap:6px;align-items:center"><input type="checkbox" id="authorExact"> Exact</label>
    </div>

    <div id="warning" class="warning"></div>
    <div id="list" class="list"></div>
  </div>

  <script>
  // ---------- Config ----------
  const MAX_ABSTRACT_CHARS = 140;

  // ---------- Safe coercion helpers ----------
  function toStr(v){ if(v==null) return ""; if(Array.isArray(v)) return v.map(toStr).join(" "); if(typeof v==="object") return JSON.stringify(v); return String(v); }
  function toStrOrNull(v){ const s=toStr(v).trim(); return s?s:null; }
  function toAuthors(v){ if(Array.isArray(v)) return v.map(toStr).filter(Boolean); if(typeof v==="string") return v.split(/\s*,\s*/).filter(Boolean); return []; }
  function toYear(v){ const n=Number(String(v??"").trim()); return Number.isFinite(n)?n:null; }
  function escapeHTML(s){ return toStr(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function attr(s){ return escapeHTML(s); }
  function brief(s, n=MAX_ABSTRACT_CHARS){ s = toStr(s).trim(); if(!s) return null; return s.length>n ? (s.slice(0, n-1)+'…') : s; }

  // ---------- Highlight helpers ----------
  function escRe(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }
  function highlightHTML(text, tokens){
    let out = escapeHTML(text ?? '');
    for(const t of tokens){
      if(!t) continue;
      const re = new RegExp(`(${escRe(t)})`, 'gi');
      out = out.replace(re, '<mark>$1</mark>');
    }
    return out;
  }

  // ---------- State ----------
  const ASSET_BASE = '/assets/projects/papers-explorer/';
  const FALLBACK_DATASETS = [
    { label: 'CVPR 2025', path: ASSET_BASE + 'cvpr_2025_papers.json' },
  ];
  const MANIFEST_URL = ASSET_BASE + 'datasets.json'; // optional

  let DATA = [];   // normalized
  let VIEW = [];   // filtered/sorted
  let INDEX = [];  // search bag

  // ---------- UI ----------
  const elDataset = document.getElementById('dataset');
  const elWarn = document.getElementById('warning');
  const elList = document.getElementById('list');
  const elCount = document.getElementById('count');
  const elSources = document.getElementById('sources');
  const elQ = document.getElementById('q');
  const elYear = document.getElementById('year');
  const elVenue = document.getElementById('venue');
  const elSort = document.getElementById('sort');
  const elClear = document.getElementById('btnClear');
  const elCSV = document.getElementById('btnCSV');
  const elLoading = document.getElementById('loading');
  const elSpin = document.getElementById('spin');
  const elTitleFilter = document.getElementById('titleFilter');
  const elTitleExact = document.getElementById('titleExact');
  const elAuthorFilter = document.getElementById('authorFilter');
  const elAuthorExact = document.getElementById('authorExact');

  function setLoading(on){ elLoading.style.display = on ? 'inline-flex' : 'none'; elSpin.style.display = on ? 'inline-block' : 'none'; }

  // ---------- Normalize ----------
  function normalizeArray(data){
    return (Array.isArray(data)?data:[]).map(x=>({
      title: toStr(x.title ?? x.paper_title),
      authors: toAuthors(x.authors),
      abstract: toStrOrNull(x.abstract),
      pdf_url: toStrOrNull(x.pdf_url ?? x.pdf),
      paper_url: toStrOrNull(x.paper_url ?? x.url),
      venue: toStrOrNull(x.venue ?? x.conference),
      year: toYear(x.year),
    }));
  }

  // ---------- Render ----------
  function renderList(rows, tokens=[]){
    elList.innerHTML = '';
    const frag = document.createDocumentFragment();
    for(const r of rows){
      const art = document.createElement('article');
      art.className = 'card';
      const titleHTML   = tokens.length ? highlightHTML(r.title || '(Untitled)', tokens) : escapeHTML(r.title || '(Untitled)');
      const authorsText = (r.authors||[]).join(', ');
      const authorsHTML = tokens.length ? highlightHTML(authorsText, tokens) : escapeHTML(authorsText);
      const absText     = brief(r.abstract);
      const absHTML     = absText ? (tokens.length ? highlightHTML(absText, tokens) : escapeHTML(absText)) : '';

      art.innerHTML = `
        <div class="title">${titleHTML}</div>
        <div class="meta">
          ${r.year ? `<span>${r.year}</span>` : ''}
          ${r.venue ? `<span>• ${escapeHTML(r.venue)}</span>` : ''}
        </div>
        ${authorsText ? `<div class="authors">${authorsHTML}</div>` : ''}
        ${absHTML ? `<div class="abs">${absHTML}</div>` : ''}
        <div class="links">
          ${r.pdf_url ? `<a href="${attr(r.pdf_url)}" target="_blank" rel="noopener">PDF</a>` : ''}
          ${r.paper_url ? `<a href="${attr(r.paper_url)}" target="_blank" rel="noopener">Source</a>` : ''}
        </div>`;
      frag.appendChild(art);
    }
    elList.appendChild(frag);
    elCount.textContent = `${rows.length.toLocaleString()} results`;
  }

  // ---------- Index / search ----------
  function buildIndex(){
    INDEX = DATA.map(r => (toStr(r.title)+' '+toStr(r.abstract)+' '+toStr((r.authors||[]).join(' '))).toLowerCase());
    const years = Array.from(new Set(DATA.map(r => r.year).filter(Boolean))).sort((a,b)=>b-a);
    elYear.innerHTML = `<option value="">Year (all)</option>` + years.map(y=>`<option value="${y}">${y}</option>`).join('');
    const venues = Array.from(new Set(DATA.map(r => r.venue).filter(Boolean))).slice(0,6);
    elSources.textContent = venues.length ? `Venues: ${venues.join(' · ')}` : '';
  }

  function scoreRow(idx, qTokens){
    if (!qTokens.length) return 0;
    const bag = INDEX[idx];
    let score = 0;
    for(const t of qTokens){
      if (!t) continue;
      const m = bag.split(t).length - 1;
      score += m;
      const title = toStr(DATA[idx].title).toLowerCase();
      if (title.includes(t)) score += 2;
    }
    return score;
  }

  function matchesTitle(r, text, exact){
    if(!text) return true;
    const t = toStr(r.title).toLowerCase();
    const q = toStr(text).toLowerCase().trim();
    return exact ? (t === q) : t.includes(q);
  }

  function matchesAuthor(r, text, exact){
    if(!text) return true;
    const q = toStr(text).toLowerCase().trim();
    const authors = (r.authors || []).map(a => toStr(a).toLowerCase().trim()).filter(Boolean);
    if (!authors.length) return false;
    if (exact) return authors.some(a => a === q);
    // substring match against any author
    return authors.some(a => a.includes(q));
  }

  function applyFilters(){
    const q = toStr(elQ.value).trim().toLowerCase();
    const yr = toStr(elYear.value).trim();
    const vn = toStr(elVenue.value).trim().toLowerCase();
    const sort = elSort.value;
    const qTokens = q ? q.split(/\s+/).filter(Boolean) : [];

    const titleText = elTitleFilter.value || '';
    const titleExact = elTitleExact.checked;
    const authorText = elAuthorFilter.value || '';
    const authorExact = elAuthorExact.checked;

    let rows = [];
    for (let i=0;i<DATA.length;i++){
      const r = DATA[i];
      if (yr && String(r.year) !== yr) continue;
      if (vn && !toStr(r.venue).toLowerCase().includes(vn)) continue;
      if (!matchesTitle(r, titleText, titleExact)) continue;
      if (!matchesAuthor(r, authorText, authorExact)) continue;

      if (qTokens.length){
        const s = scoreRow(i, qTokens);
        if (s <= 0) continue;
        rows.push({row:r, s});
      } else {
        rows.push({row:r, s:0});
      }
    }

    if (sort === 'relevance'){
      rows.sort((a,b)=> b.s - a.s);
    } else if (sort === 'year_desc'){
      rows.sort((a,b)=> (b.row.year||0) - (a.row.year||0));
    } else if (sort === 'year_asc'){
      rows.sort((a,b)=> (a.row.year||0) - (b.row.year||0));
    } else if (sort === 'title_asc'){
      rows.sort((a,b)=> toStr(a.row.title).localeCompare(toStr(b.row.title)));
    }

    VIEW = rows.map(x=>x.row);
    // We highlight only free-text tokens (q). Exact filters are not highlighted to avoid confusion.
    renderList(VIEW, qTokens);
  }

  // ---------- CSV ----------
  function downloadCSV(rows){
    const header = ["title","year","venue","authors","pdf_url","paper_url","abstract"];
    const lines = [header.join(",")];
    for (const r of rows){
      const vals = [
        toStr(r.title),
        toStr(r.year),
        toStr(r.venue),
        toStr((r.authors||[]).join("; ")),
        toStr(r.pdf_url),
        toStr(r.paper_url),
        toStr(r.abstract)
      ].map(s => `"${toStr(s).replace(/"/g,'""')}"`);
      lines.push(vals.join(","));
    }
    const blob = new Blob([lines.join("\n")], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `papers_${Date.now()}.csv`; a.click();
    URL.revokeObjectURL(url);
  }

  // ---------- Load dataset ----------
  async function loadDataset(path){
    const absUrl = location.origin + (path.startsWith('/') ? path : ('/'+path));
    elWarn.style.display = 'none'; elWarn.textContent = ''; setLoading(true);
    try{
      const res = await fetch(absUrl + (absUrl.includes('?') ? '&' : '?') + 'nocache=' + Date.now(), {cache:'no-store'});
      if (!res.ok) throw new Error(`HTTP ${res.status} on ${absUrl}`);
      let data;
      try{
        data = await res.json();
      }catch(parseErr){
        const raw = await (await fetch(absUrl, {cache:'no-store'})).text();
        const sample = raw.slice(0,200).replace(/\n/g,' ');
        throw new Error(`JSON parse error: ${(parseErr && parseErr.message)||parseErr}. Sample: ${sample}`);
      }
      DATA = normalizeArray(data);
      buildIndex();
      // Reset filters
      elQ.value=''; elYear.value=''; elVenue.value=''; elSort.value='relevance';
      elTitleFilter.value=''; elTitleExact.checked=false;
      elAuthorFilter.value=''; elAuthorExact.checked=false;
      applyFilters();
    }catch(e){
      const msg = (e && e.message) ? e.message : String(e);
      console.error('[JSON load error]', msg);
      elWarn.textContent = `Failed to load JSON: ${msg}`;
      elWarn.style.display = 'block';
      DATA=[]; INDEX=[]; VIEW=[]; renderList([]);
    }finally{
      setLoading(false);
    }
  }

  // ---------- Populate datasets ----------
  async function populateDatasets(){
    try{
      const res = await fetch(location.origin + MANIFEST_URL + '?nocache=' + Date.now(), {cache:'no-store'});
      if (res.ok){
        const arr = await res.json();
        if (Array.isArray(arr) && arr.length){
          arr.forEach(it => {
            const opt = document.createElement('option');
            opt.value = it.path; opt.textContent = it.label || it.path;
            elDataset.appendChild(opt);
          });
          return;
        }
      }
    }catch(_){} // ignore manifest errors

    FALLBACK_DATASETS.forEach(it => {
      const opt = document.createElement('option');
      opt.value = it.path; opt.textContent = it.label;
      elDataset.appendChild(opt);
    });
  }

  // ---------- Events ----------
  function debounce(fn, ms=160){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }

  document.getElementById('btnCSV').addEventListener('click', ()=> downloadCSV(VIEW.length ? VIEW : DATA));
  document.getElementById('btnClear').addEventListener('click', ()=>{
    elQ.value=''; elYear.value=''; elVenue.value=''; elSort.value='relevance';
    elTitleFilter.value=''; elTitleExact.checked=false;
    elAuthorFilter.value=''; elAuthorExact.checked=false;
    applyFilters();
  });

  elQ.addEventListener('input', debounce(applyFilters, 120));
  elYear.addEventListener('change', applyFilters);
  elVenue.addEventListener('input', debounce(applyFilters, 120));
  elSort.addEventListener('change', applyFilters);
  elTitleFilter.addEventListener('input', debounce(applyFilters, 120));
  elTitleExact.addEventListener('change', applyFilters);
  elAuthorFilter.addEventListener('input', debounce(applyFilters, 120));
  elAuthorExact.addEventListener('change', applyFilters);

  elDataset.addEventListener('change', () => {
    const path = elDataset.value;
    if (path) loadDataset(path);
  });

  // ---------- Boot ----------
  (async function boot(){
    await populateDatasets();
    const p = new URLSearchParams(location.search);
    const requested = p.get('data');
    if (requested){
      let opt = Array.from(elDataset.options).find(o => o.value === requested);
      if (!opt){
        opt = document.createElement('option');
        opt.value = requested; opt.textContent = requested; elDataset.appendChild(opt);
      }
      elDataset.value = requested;
      loadDataset(requested);
    } else if (elDataset.options.length > 1){
      elDataset.selectedIndex = 1; // first real dataset
      loadDataset(elDataset.value);
    }
  })();
  </script>
</body>
</html>
